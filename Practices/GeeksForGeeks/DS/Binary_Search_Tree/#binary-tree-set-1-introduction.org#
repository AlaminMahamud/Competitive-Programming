#+TITLE: Binary Tree | Set 1 (Introduction)
*Trees*: Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures,
trees are hierarchical data structures.

*Tree vocabulary*: The topmost node is called root of the tree. The elements that are directly under an element are called its children. The element directly  above somethings is called its parent. For example, a is a child of f.

* Why Trees?
* Main applications of trees include
* Binary Tree
A tree whose elements have at most 2 children is called binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.
* Binary Tree representation in C

#+BEGIN_SRC c++
#include <cstdio>
using namespace std;

int main(){
cout << "Hello World" << endl;
}
#+END_SRC

#+BEGIN_SRC C
printf("Hello World");
#+END_SRC

#+RESULTS:
: Hello World

#+BEGIN_SRC cpp
#include <iostream>
using namespace std;

int main(){
cout << "Hello World" << endl;
return 0;
}
#+END_SRC

#+RESULTS:
: Hello World

#+BEGIN_SRC cpp
  #include <bits/stdc++.h>
using namespace std;
  struct node{
  int data;
  struct node *left;
  struct node *right;
  };

  /* newNode() allocates a new node with the given data and NULL left and right pointers */
  struct node* newNode(int data){
    // Allocate memory for new node
    struct node* node = (struct node*) malloc(sizeof(struct node));

    // Assign data to this node
    node->data = data;

    // Initialize left and right children as NULL
    node->left = NULL;
    node->right = NULL;

    return node;
  }

void traverseNodes(struct node* root){
if(root!=NULL)
cout << root->data << endl;
if(root->left != NULL)
traverseNodes(root->left);
if(root->right != NULL)
traverseNodes(root->right);
}

int main(){
// create root
struct node * root = newNode(1);
// following is the tree after above statement
root->left = newNode(2);
root->right = newNode(3);

root->left->left = newNode(4);

traverseNodes(root);
return 0;
}

#+END_SRC

#+RESULTS:
| 1 |
| 2 |
| 4 |
| 3 |

